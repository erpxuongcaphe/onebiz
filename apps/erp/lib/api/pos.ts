import { supabaseUntyped as supabase } from "@/lib/supabase";
import {
    Order,
    OrderItem,
    CreateOrderInput,
    UpdateOrderInput,
    ProcessPaymentInput,
    OrderStatus
} from "@/lib/types/pos";

// === ORDERS ===

export async function getOrders(
    branchId: string,
    filters?: {
        status?: OrderStatus;
        tableId?: string;
        date?: string;
    }
): Promise<Order[]> {
    let query = supabase
        .from('orders')
        .select(`
            *,
            items:order_items(*),
            table:pos_tables(id, table_number, name)
        `)
        .eq('branch_id', branchId);

    if (filters?.status) {
        query = query.eq('status', filters.status);
    }
    if (filters?.tableId) {
        query = query.eq('table_id', filters.tableId);
    }
    if (filters?.date) {
        query = query.gte('created_at', `${filters.date}T00:00:00`)
            .lt('created_at', `${filters.date}T23:59:59`);
    }

    const { data, error } = await query.order('created_at', { ascending: false });

    if (error) throw error;
    return data || [];
}

export async function getActiveOrders(branchId: string): Promise<Order[]> {
    const { data, error } = await supabase
        .from('orders')
        .select(`
            *,
            items:order_items(*),
            table:pos_tables(id, table_number, name)
        `)
        .eq('branch_id', branchId)
        .in('status', ['draft', 'confirmed', 'preparing', 'ready'])
        .order('created_at', { ascending: false });

    if (error) throw error;
    return data || [];
}

export async function getOrderById(id: string): Promise<Order | null> {
    const { data, error } = await supabase
        .from('orders')
        .select(`
            *,
            items:order_items(
                *,
                product:products(id, name, code, image_url)
            ),
            table:pos_tables(id, table_number, name)
        `)
        .eq('id', id)
        .single();

    if (error) throw error;
    return data;
}

export async function getOrderByTable(tableId: string): Promise<Order | null> {
    const { data, error } = await supabase
        .from('orders')
        .select(`
            *,
            items:order_items(
                *,
                product:products(id, name, code, image_url)
            )
        `)
        .eq('table_id', tableId)
        .in('status', ['draft', 'confirmed', 'preparing', 'ready'])
        .order('created_at', { ascending: false })
        .limit(1)
        .single();

    if (error && error.code !== 'PGRST116') throw error; // PGRST116 = no rows
    return data;
}

export async function createOrder(input: CreateOrderInput): Promise<Order> {
    // 1. Create order (order_number will be auto-generated by trigger)
    const { data: order, error: orderError } = await supabase
        .from('orders')
        .insert([{
            branch_id: input.branch_id,
            table_id: input.table_id,
            order_type: input.order_type,
            customer_name: input.customer_name,
            customer_phone: input.customer_phone,
            notes: input.notes,
            status: 'draft'
        }])
        .select()
        .single();

    if (orderError) throw orderError;

    // 2. Create order items
    if (input.items && input.items.length > 0) {
        const items = input.items.map(item => ({
            order_id: order.id,
            product_id: item.product_id,
            product_name: item.product_name,
            quantity: item.quantity,
            unit_price: item.unit_price,
            line_total: item.quantity * item.unit_price,
            notes: item.notes
        }));

        const { error: itemsError } = await supabase
            .from('order_items')
            .insert(items);

        if (itemsError) throw itemsError;
    }

    // 3. Return full order with items
    return getOrderById(order.id) as Promise<Order>;
}

export async function updateOrder(id: string, updates: UpdateOrderInput): Promise<Order> {
    const { error } = await supabase
        .from('orders')
        .update({
            ...updates,
            updated_at: new Date().toISOString()
        })
        .eq('id', id);

    if (error) throw error;
    return getOrderById(id) as Promise<Order>;
}

export async function updateOrderStatus(id: string, status: OrderStatus): Promise<Order> {
    const updates: Record<string, unknown> = {
        status,
        updated_at: new Date().toISOString()
    };

    if (status === 'completed') {
        updates.completed_at = new Date().toISOString();
    }

    const { error } = await supabase
        .from('orders')
        .update(updates)
        .eq('id', id);

    if (error) throw error;
    return getOrderById(id) as Promise<Order>;
}

// === ORDER ITEMS ===

export async function addOrderItem(
    orderId: string,
    item: { product_id: string; product_name: string; quantity: number; unit_price: number; notes?: string }
): Promise<OrderItem> {
    const { data, error } = await supabase
        .from('order_items')
        .insert([{
            order_id: orderId,
            product_id: item.product_id,
            product_name: item.product_name,
            quantity: item.quantity,
            unit_price: item.unit_price,
            line_total: item.quantity * item.unit_price,
            notes: item.notes
        }])
        .select()
        .single();

    if (error) throw error;
    return data;
}

export async function updateOrderItem(
    itemId: string,
    updates: { quantity?: number; notes?: string }
): Promise<OrderItem> {
    // Get current item to recalculate
    const { data: current } = await supabase
        .from('order_items')
        .select('unit_price')
        .eq('id', itemId)
        .single();

    const updateData: Record<string, unknown> = { ...updates };
    if (updates.quantity && current) {
        updateData.line_total = updates.quantity * current.unit_price;
    }

    const { data, error } = await supabase
        .from('order_items')
        .update(updateData)
        .eq('id', itemId)
        .select()
        .single();

    if (error) throw error;
    return data;
}

export async function removeOrderItem(itemId: string): Promise<void> {
    const { error } = await supabase
        .from('order_items')
        .delete()
        .eq('id', itemId);

    if (error) throw error;
}

// === PAYMENT ===

export async function processPayment(orderId: string, input: ProcessPaymentInput): Promise<Order> {
    const order = await getOrderById(orderId);
    if (!order) throw new Error('Order not found');

    const change = input.amount_paid - order.total;
    const paymentStatus = input.amount_paid >= order.total ? 'paid' : 'partial';

    const { error } = await supabase
        .from('orders')
        .update({
            payment_method: input.payment_method,
            amount_paid: input.amount_paid,
            change_amount: Math.max(0, change),
            payment_status: paymentStatus,
            status: paymentStatus === 'paid' ? 'completed' : order.status,
            completed_at: paymentStatus === 'paid' ? new Date().toISOString() : null,
            updated_at: new Date().toISOString()
        })
        .eq('id', orderId);

    if (error) throw error;
    return getOrderById(orderId) as Promise<Order>;
}

// === REPORTS ===

export async function getTodaySummary(branchId: string): Promise<{
    totalOrders: number;
    completedOrders: number;
    totalRevenue: number;
    avgOrderValue: number;
}> {
    const today = new Date().toISOString().split('T')[0];

    const { data, error } = await supabase
        .from('orders')
        .select('id, status, total, payment_status')
        .eq('branch_id', branchId)
        .gte('created_at', `${today}T00:00:00`)
        .lt('created_at', `${today}T23:59:59`);

    if (error) throw error;

    const orders = data || [];
    const completed = orders.filter(o => o.status === 'completed');
    const totalRevenue = completed.reduce((sum, o) => sum + (o.total || 0), 0);

    return {
        totalOrders: orders.length,
        completedOrders: completed.length,
        totalRevenue,
        avgOrderValue: completed.length > 0 ? totalRevenue / completed.length : 0
    };
}
